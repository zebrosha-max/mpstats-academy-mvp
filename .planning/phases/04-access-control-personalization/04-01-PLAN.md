---
phase: 04-access-control-personalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/api/src/routers/diagnostic.ts
  - packages/api/src/routers/learning.ts
  - apps/web/src/components/learning/DiagnosticGateBanner.tsx
  - apps/web/src/app/(main)/learn/[id]/page.tsx
autonomous: true
requirements:
  - ACCESS-01
  - ACCESS-03

must_haves:
  truths:
    - "User without completed diagnostic sees motivating banner instead of video+summary+chat on lesson page"
    - "User with completed diagnostic sees video+summary+chat normally on lesson page"
    - "On diagnostic completion, recommended lesson IDs are persisted in LearningPath.lessons"
    - "Re-taking diagnostic rebuilds the recommended path from new SkillProfile"
    - "Lesson title, breadcrumb, category badge remain visible even when content is gated"
  artifacts:
    - path: "packages/api/src/routers/diagnostic.ts"
      provides: "hasCompletedDiagnostic query + path generation on completion"
      contains: "hasCompletedDiagnostic"
    - path: "packages/api/src/routers/learning.ts"
      provides: "getRecommendedPath query returning persisted lesson IDs"
      contains: "getRecommendedPath"
    - path: "apps/web/src/components/learning/DiagnosticGateBanner.tsx"
      provides: "Gate banner component with CTA to /diagnostic"
      min_lines: 20
    - path: "apps/web/src/app/(main)/learn/[id]/page.tsx"
      provides: "Conditional rendering: banner vs content based on diagnostic status"
      contains: "hasCompletedDiagnostic"
  key_links:
    - from: "apps/web/src/app/(main)/learn/[id]/page.tsx"
      to: "trpc.diagnostic.hasCompletedDiagnostic"
      via: "tRPC useQuery"
      pattern: "trpc\\.diagnostic\\.hasCompletedDiagnostic"
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "prisma.learningPath.upsert"
      via: "path persistence on completion"
      pattern: "learningPath\\.upsert"
---

<objective>
Add soft content gating on lesson pages and persist recommended learning path on diagnostic completion.

Purpose: Users without a completed diagnostic see a motivating banner instead of lesson content (video, AI summary, RAG chat). On diagnostic completion, a full recommended path (all lessons from weak categories) is generated and saved to LearningPath.lessons for cross-session persistence.

Output: Backend endpoints (hasCompletedDiagnostic, getRecommendedPath, path generation), DiagnosticGateBanner component, gated lesson page.
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-access-control-personalization/04-CONTEXT.md
@.planning/phases/04-access-control-personalization/04-RESEARCH.md
@packages/api/src/routers/diagnostic.ts
@packages/api/src/routers/learning.ts
@apps/web/src/app/(main)/learn/[id]/page.tsx
@packages/db/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend endpoints and path generation logic</name>
  <files>
    packages/api/src/routers/diagnostic.ts
    packages/api/src/routers/learning.ts
  </files>
  <action>
**In diagnostic.ts:**

1. Add a new `hasCompletedDiagnostic` query (protectedProcedure):
```typescript
hasCompletedDiagnostic: protectedProcedure.query(async ({ ctx }) => {
  try {
    const count = await ctx.prisma.diagnosticSession.count({
      where: { userId: ctx.user.id, status: 'COMPLETED' },
    });
    return count > 0;
  } catch (error) {
    handleDatabaseError(error);
  }
}),
```

2. Add a new helper function `generateFullRecommendedPath` ABOVE the router definition:
```typescript
async function generateFullRecommendedPath(
  prisma: PrismaClient,
  skillProfile: SkillProfile,
): Promise<string[]> {
  const categories: Array<{ key: keyof SkillProfile; category: SkillCategory }> = [
    { key: 'analytics', category: 'ANALYTICS' },
    { key: 'marketing', category: 'MARKETING' },
    { key: 'content', category: 'CONTENT' },
    { key: 'operations', category: 'OPERATIONS' },
    { key: 'finance', category: 'FINANCE' },
  ];

  // Sort by weakness (lowest score first)
  const weakCategories = categories
    .map((c) => ({ ...c, score: skillProfile[c.key] }))
    .filter((c) => c.score < 50)
    .sort((a, b) => a.score - b.score);

  const lessonIds: string[] = [];
  for (const cat of weakCategories) {
    const lessons = await prisma.lesson.findMany({
      where: { skillCategory: cat.category },
      orderBy: { order: 'asc' },
      select: { id: true },
    });
    lessonIds.push(...lessons.map((l) => l.id));
  }

  return lessonIds;
}
```

3. In the `submitAnswer` mutation, inside the `if (isComplete)` block, AFTER the session status update and BEFORE `activeSessionQuestions.delete(...)`, add path generation and persistence:
```typescript
// Generate and persist recommended learning path
const fullPath = await generateFullRecommendedPath(ctx.prisma, skillProfile);
await ctx.prisma.learningPath.upsert({
  where: { userId: ctx.user.id },
  update: { lessons: fullPath, generatedAt: new Date() },
  create: { userId: ctx.user.id, lessons: fullPath },
});
```

**In learning.ts:**

4. Add a new `getRecommendedPath` query (protectedProcedure):
```typescript
getRecommendedPath: protectedProcedure.query(async ({ ctx }) => {
  try {
    const path = await ctx.prisma.learningPath.findUnique({
      where: { userId: ctx.user.id },
      select: { lessons: true, generatedAt: true },
    });

    if (!path || !Array.isArray(path.lessons) || path.lessons.length === 0) {
      return null;
    }

    // Fetch full lesson data for recommended IDs with progress
    const recommendedIds = path.lessons as string[];
    const lessons = await ctx.prisma.lesson.findMany({
      where: { id: { in: recommendedIds } },
      include: {
        progress: {
          where: { path: { userId: ctx.user.id } },
        },
        course: { select: { title: true } },
      },
      orderBy: { order: 'asc' },
    });

    // Preserve the recommended order (by weakness priority)
    const lessonMap = new Map(lessons.map((l) => [l.id, l]));
    const orderedLessons = recommendedIds
      .map((id) => lessonMap.get(id))
      .filter(Boolean)
      .map((l) => ({
        id: l!.id,
        courseId: l!.courseId,
        courseName: l!.course.title,
        title: l!.title,
        description: l!.description,
        videoUrl: l!.videoUrl || '',
        videoId: l!.videoId,
        duration: l!.duration || 0,
        order: l!.order,
        skillCategory: l!.skillCategory,
        skillLevel: l!.skillLevel,
        status: l!.progress[0]?.status || 'NOT_STARTED' as const,
        watchedPercent: l!.progress[0]?.watchedPercent || 0,
      }));

    const completedCount = orderedLessons.filter((l) => l.status === 'COMPLETED').length;

    return {
      generatedAt: path.generatedAt,
      lessons: orderedLessons,
      totalLessons: orderedLessons.length,
      completedLessons: completedCount,
    };
  } catch (error) {
    handleDatabaseError(error);
  }
}),
```

Place this new procedure inside the `learningRouter` definition, after the existing `getPath` procedure.

**Important:** Both routers already use `protectedProcedure`, `handleDatabaseError`, and `PrismaClient` — no new imports needed in diagnostic.ts. In learning.ts, no new imports needed either since all types are already available.
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && npx tsc --noEmit --project packages/api/tsconfig.json 2>&1 | head -20</automated>
    <manual>Check that diagnostic.ts has hasCompletedDiagnostic query and generateFullRecommendedPath helper, and learning.ts has getRecommendedPath query</manual>
  </verify>
  <done>
    - hasCompletedDiagnostic returns boolean based on COMPLETED DiagnosticSession count
    - generateFullRecommendedPath creates full lesson list from categories with score < 50
    - submitAnswer persists recommended path to LearningPath.lessons on completion
    - getRecommendedPath returns ordered lessons with progress data and completion stats
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DiagnosticGateBanner and wire lesson page gating</name>
  <files>
    apps/web/src/components/learning/DiagnosticGateBanner.tsx
    apps/web/src/app/(main)/learn/[id]/page.tsx
  </files>
  <action>
**Create `apps/web/src/components/learning/DiagnosticGateBanner.tsx`:**

New component following project conventions ('use client', named exports, mp-* design tokens):

```typescript
'use client';

import Link from 'next/link';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';

export function DiagnosticGateBanner() {
  return (
    <Card className="shadow-mp-card border-mp-blue-200 bg-gradient-to-br from-mp-blue-50 to-white">
      <CardContent className="py-12 text-center">
        {/* Lock icon */}
        <div className="w-16 h-16 rounded-2xl bg-mp-blue-100 flex items-center justify-center mx-auto mb-4">
          <svg className="w-8 h-8 text-mp-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
              d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
          </svg>
        </div>
        <h2 className="text-heading text-mp-gray-900 mb-2">
          Пройди диагностику, чтобы получить доступ
        </h2>
        <p className="text-body text-mp-gray-500 mb-6 max-w-md mx-auto">
          Диагностика определит твои сильные и слабые стороны, и мы подберём персональный трек обучения
        </p>
        <Link href="/diagnostic">
          <Button size="lg">
            Начать диагностику
          </Button>
        </Link>
      </CardContent>
    </Card>
  );
}
```

**Modify `apps/web/src/app/(main)/learn/[id]/page.tsx`:**

1. Add import at top (after existing imports):
```typescript
import { DiagnosticGateBanner } from '@/components/learning/DiagnosticGateBanner';
```

2. Add tRPC query for diagnostic status (after existing queries, before mutations):
```typescript
const { data: hasDiagnostic, isLoading: diagLoading } = trpc.diagnostic.hasCompletedDiagnostic.useQuery();
```

3. Wrap the main content grid (`<div className="grid lg:grid-cols-3 gap-6">`) in a conditional. The current grid starts after the header `<div>` block.

Replace the existing content from the `<div className="grid lg:grid-cols-3 gap-6">` opening through its closing `</div>` with:

```tsx
{hasDiagnostic === false ? (
  <DiagnosticGateBanner />
) : (
  <div className="grid lg:grid-cols-3 gap-6">
    {/* ... existing video section + AI sidebar - keep everything exactly as is ... */}
  </div>
)}
```

- When `hasDiagnostic` is undefined (loading) or true, show the content grid as before (no flash of gate).
- When `hasDiagnostic` is explicitly `false`, show the gate banner (full width, replacing entire grid).
- The breadcrumb, title, category badge, description remain ABOVE the conditional (always visible per user decision).
- Do NOT add diagLoading to the main isLoading check — we want the page skeleton to appear based on lesson data loading, not diagnostic status. The diagnostic check resolves quickly and defaults to showing content while loading to avoid flash.
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && npx tsc --noEmit --project apps/web/tsconfig.json 2>&1 | head -20</automated>
    <manual>
      1. Visit /learn/[any-lesson-id] as a user WITHOUT completed diagnostic — should see lock banner with CTA
      2. Visit /learn/[any-lesson-id] as a user WITH completed diagnostic — should see normal video+summary+chat
      3. Verify lesson title and breadcrumb are visible in both cases
    </manual>
  </verify>
  <done>
    - DiagnosticGateBanner component exists with lock icon, motivating text, CTA button to /diagnostic
    - Lesson page shows gate banner when hasDiagnostic is false
    - Lesson page shows full content when hasDiagnostic is true or loading
    - Lesson title, breadcrumb, category badge always visible
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors for both packages/api and apps/web
2. Lesson page renders gate banner for users without diagnostic
3. Lesson page renders full content for users with diagnostic
4. Recommended path is saved to LearningPath.lessons on diagnostic completion
5. getRecommendedPath returns ordered lesson data with progress
</verification>

<success_criteria>
- hasCompletedDiagnostic endpoint returns correct boolean per user
- Recommended path generated and persisted on every diagnostic completion (including re-takes)
- Gate banner replaces video+summary+chat area, keeps lesson metadata visible
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-access-control-personalization/04-01-SUMMARY.md`
</output>
