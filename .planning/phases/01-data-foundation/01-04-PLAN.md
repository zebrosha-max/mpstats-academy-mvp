---
phase: 01-data-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - packages/api/src/routers/profile.ts
  - apps/web/src/app/(main)/dashboard/page.tsx
  - apps/web/src/components/shared/DatabaseError.tsx
autonomous: false

must_haves:
  truths:
    - "Dashboard shows real stats: lessons completed, watch time, current streak, average score"
    - "SkillProfile on dashboard comes from DB (last diagnostic), not mock"
    - "New user sees empty state: skeleton radar + 'Pass diagnostic' CTA"
    - "Activity streak shows consecutive days with any recorded activity"
    - "Supabase 521 error shows specific admin instruction message, not generic error"
  artifacts:
    - path: "packages/api/src/routers/profile.ts"
      provides: "Prisma-based profile/dashboard router with real stats"
      contains: "ctx.prisma.diagnosticSession"
    - path: "apps/web/src/components/shared/DatabaseError.tsx"
      provides: "Error component for DB unavailable states"
      contains: "DATABASE_UNAVAILABLE"
  key_links:
    - from: "packages/api/src/routers/profile.ts"
      to: "packages/api/src/routers/diagnostic.ts"
      via: "getLatestSkillProfile and getCompletedSessions functions"
      pattern: "getLatestSkillProfile|getCompletedSessions"
    - from: "packages/api/src/routers/profile.ts"
      to: "packages/db/prisma/schema.prisma"
      via: "LessonProgress, DiagnosticSession, SkillProfile queries"
      pattern: "ctx\\.prisma\\.(lessonProgress|diagnosticSession|skillProfile)"
    - from: "apps/web/src/app/(main)/dashboard/page.tsx"
      to: "packages/api/src/routers/profile.ts"
      via: "tRPC getDashboard query"
      pattern: "trpc\\.profile\\.getDashboard"
---

<objective>
Migrate the profile router to Prisma and build dashboard with real statistics from DB.

Purpose: Dashboard is the main page users see after login. It must show real data: skill profile from last diagnostic, actual lesson progress, activity streak, and recent activity. This is the final router migration that ties together data from learning (LessonProgress) and diagnostic (DiagnosticSession, SkillProfile).

Output:
- Rewritten profile.ts using Prisma for all data
- DatabaseError component for Supabase 521 and generic DB errors
- Updated dashboard page with empty state for new users
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-02-SUMMARY.md
@.planning/phases/01-data-foundation/01-03-SUMMARY.md

@packages/db/prisma/schema.prisma
@packages/api/src/trpc.ts
@packages/api/src/routers/profile.ts
@packages/api/src/routers/diagnostic.ts
@packages/api/src/utils/ensure-user-profile.ts
@packages/api/src/utils/db-errors.ts
@packages/shared/src/types/index.ts
@apps/web/src/app/(main)/dashboard/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite profile router with Prisma queries and real stats</name>
  <files>
    packages/api/src/routers/profile.ts
  </files>
  <action>
Completely rewrite `packages/api/src/routers/profile.ts` to use Prisma for all data.

**Remove these imports:**
- `getMockDashboardData`, `MOCK_USER_STATS`, `MOCK_RECENT_ACTIVITY` from `../mocks/dashboard`
- `getLatestSkillProfile` import from `./diagnostic` (will be replaced with direct Prisma query OR updated import — the exported function from diagnostic.ts now takes `prisma` as first arg)

**Add imports:**
- `ensureUserProfile` from `../utils/ensure-user-profile`
- `handleDatabaseError` from `../utils/db-errors`
- `getLatestSkillProfile`, `getCompletedSessions` from `./diagnostic` (updated async versions with Prisma)

**Rewrite each procedure:**

**`get` (profile):**
- Call `ensureUserProfile(ctx.prisma, ctx.user)` to ensure profile exists
- Query with skillProfile include: `ctx.prisma.userProfile.findUnique({ where: { id: ctx.user.id }, include: { skillProfile: true } })`
- Remove the try/catch mock fallback — errors should propagate via `handleDatabaseError`
- Map to expected return type

**`getDashboard`:**
This is the most complex procedure. Query real data in parallel:

```typescript
getDashboard: protectedProcedure.query(async ({ ctx }) => {
  await ensureUserProfile(ctx.prisma, ctx.user);

  const [
    skillProfile,
    learningPath,
    completedDiagnostics,
    allProgress,
  ] = await Promise.all([
    ctx.prisma.skillProfile.findUnique({ where: { userId: ctx.user.id } }),
    ctx.prisma.learningPath.findUnique({
      where: { userId: ctx.user.id },
      include: {
        progress: {
          include: { lesson: true },
          orderBy: { completedAt: 'desc' },
        },
      },
    }),
    ctx.prisma.diagnosticSession.findMany({
      where: { userId: ctx.user.id, status: 'COMPLETED' },
      orderBy: { completedAt: 'desc' },
      take: 10,
    }),
    ctx.prisma.lessonProgress.findMany({
      where: { path: { userId: ctx.user.id } },
      include: { lesson: true },
      orderBy: { completedAt: 'desc' },
    }),
  ]);

  // Calculate stats
  const completedLessons = allProgress.filter(p => p.status === 'COMPLETED');
  const totalWatchTime = completedLessons.reduce((sum, p) => sum + (p.lesson.duration || 0), 0);
  const averageScore = completedDiagnostics.length > 0
    ? Math.round(completedDiagnostics.reduce((sum, d) => {
        // Calculate score from answers
        // ... need to include answers or store score on session
      }, 0) / completedDiagnostics.length)
    : 0;

  // Activity streak calculation
  const currentStreak = calculateCurrentStreak(allProgress, completedDiagnostics);

  // Recent activity (combine lesson completions + diagnostics)
  const recentActivity = buildRecentActivity(allProgress, completedDiagnostics);

  // Next lesson recommendation
  const nextLesson = await getNextUncompletedLesson(ctx.prisma, ctx.user.id, allProgress);

  // Completion percent (completed lessons / total lessons)
  const totalLessons = await ctx.prisma.lesson.count();
  const completionPercent = totalLessons > 0
    ? Math.round((completedLessons.length / totalLessons) * 100)
    : 0;

  return {
    stats: {
      totalLessonsCompleted: completedLessons.length,
      totalWatchTime,
      currentStreak,
      longestStreak: 0, // Calculate from full history if needed, 0 for MVP
      averageScore,
      lastActivityAt: completedLessons[0]?.completedAt || completedDiagnostics[0]?.completedAt || null,
    },
    skillProfile: skillProfile ? {
      analytics: skillProfile.analytics,
      marketing: skillProfile.marketing,
      content: skillProfile.content,
      operations: skillProfile.operations,
      finance: skillProfile.finance,
    } : null,
    recentActivity,
    nextLesson,
    completionPercent,
  };
}),
```

**Helper functions to create:**

```typescript
// Calculate consecutive days with activity (lessons or diagnostics)
function calculateCurrentStreak(
  lessonProgress: Array<{ completedAt: Date | null }>,
  diagnostics: Array<{ completedAt: Date | null }>
): number {
  // Collect all activity dates
  const activityDates = new Set<string>();
  lessonProgress.forEach(p => {
    if (p.completedAt) activityDates.add(p.completedAt.toISOString().split('T')[0]);
  });
  diagnostics.forEach(d => {
    if (d.completedAt) activityDates.add(d.completedAt.toISOString().split('T')[0]);
  });

  if (activityDates.size === 0) return 0;

  // Sort dates descending, count consecutive days from today
  const sorted = [...activityDates].sort().reverse();
  const today = new Date().toISOString().split('T')[0];

  // Check if today or yesterday has activity
  let streak = 0;
  let checkDate = new Date();

  for (let i = 0; i < 365; i++) {
    const dateStr = checkDate.toISOString().split('T')[0];
    if (activityDates.has(dateStr)) {
      streak++;
      checkDate.setDate(checkDate.getDate() - 1);
    } else if (i === 0) {
      // Today has no activity, check from yesterday
      checkDate.setDate(checkDate.getDate() - 1);
      continue;
    } else {
      break;
    }
  }

  return streak;
}

// Build recent activity list from real data
function buildRecentActivity(
  lessonProgress: Array<{ id: string; completedAt: Date | null; status: string; lesson: { id: string; courseId: string; title: string } }>,
  diagnostics: Array<{ id: string; completedAt: Date | null; status: string }>
): RecentActivity[] {
  const activities: RecentActivity[] = [];

  lessonProgress
    .filter(p => p.completedAt)
    .slice(0, 5)
    .forEach(p => {
      activities.push({
        id: `lesson-${p.id}`,
        type: p.status === 'COMPLETED' ? 'lesson_completed' : 'lesson_started',
        title: p.lesson.title,
        description: p.status === 'COMPLETED' ? 'Урок завершён' : 'Урок начат',
        timestamp: p.completedAt!,
        metadata: { lessonId: p.lesson.id, courseId: p.lesson.courseId },
      });
    });

  diagnostics.slice(0, 3).forEach(d => {
    activities.push({
      id: `diag-${d.id}`,
      type: 'diagnostic_completed',
      title: 'Диагностика навыков',
      description: 'Диагностика завершена',
      timestamp: d.completedAt!,
    });
  });

  return activities.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()).slice(0, 10);
}

// Get next uncompleted lesson
async function getNextUncompletedLesson(prisma: PrismaClient, userId: string, progress: any[]): Promise<LessonWithProgress | null> {
  const completedIds = new Set(progress.filter(p => p.status === 'COMPLETED').map(p => p.lessonId));

  const nextLesson = await prisma.lesson.findFirst({
    where: { id: { notIn: [...completedIds] } },
    orderBy: [{ course: { order: 'asc' } }, { order: 'asc' }],
    include: { course: true },
  });

  if (!nextLesson) return null;

  const inProgress = progress.find(p => p.lessonId === nextLesson.id);
  return {
    id: nextLesson.id,
    courseId: nextLesson.courseId,
    title: nextLesson.title,
    description: nextLesson.description,
    videoUrl: nextLesson.videoUrl || '',
    videoId: nextLesson.videoId,
    duration: nextLesson.duration || 0,
    order: nextLesson.order,
    skillCategory: nextLesson.skillCategory,
    skillLevel: nextLesson.skillLevel,
    status: inProgress?.status || 'NOT_STARTED',
    watchedPercent: inProgress?.watchedPercent || 0,
  };
}
```

**`getSkillProfile`:**
- Direct Prisma query: `ctx.prisma.skillProfile.findUnique({ where: { userId: ctx.user.id } })`
- Map to `SkillProfile` interface
- Return null if not found (no mock fallback)

**`getStats`:**
- Same queries as getDashboard stats section — or remove this procedure and have dashboard page use getDashboard only

**`getRecentActivity`:**
- Same as buildRecentActivity — or remove and consolidate into getDashboard

**`update` (profile update):**
- `ensureUserProfile` first, then `ctx.prisma.userProfile.update()`
- Remove try/catch mock fallback — use `handleDatabaseError`

**`updateSettings`:**
- Keep as mock for now (no Settings model in schema). This is fine — settings are a nice-to-have.

**Error handling:** Wrap all DB-touching procedures in try/catch with `handleDatabaseError(error)`.
  </action>
  <verify>
- `pnpm typecheck` passes
- No imports from `../mocks/dashboard` remain in profile.ts
- `grep "MOCK_USER_STATS\|MOCK_RECENT_ACTIVITY\|getMockDashboardData" packages/api/src/routers/profile.ts` returns nothing
- `grep "ctx.prisma" packages/api/src/routers/profile.ts` returns multiple matches
  </verify>
  <done>
- Dashboard returns real stats from DB: lessons completed, watch time, streak, average score
- SkillProfile comes from DB (last diagnostic result)
- Recent activity built from real LessonProgress + DiagnosticSession data
- Activity streak calculated from consecutive activity days
- New user gets null skillProfile and empty stats (not mock data)
- Error handling via handleDatabaseError (no mock fallback)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DatabaseError component and update dashboard empty state</name>
  <files>
    apps/web/src/components/shared/DatabaseError.tsx
    apps/web/src/app/(main)/dashboard/page.tsx
  </files>
  <action>
**1. Create `apps/web/src/components/shared/DatabaseError.tsx`:**

A reusable component for database error states. Per user decision: Supabase 521 gets a special message.

```typescript
'use client';

interface DatabaseErrorProps {
  error: { message: string } | null;
  className?: string;
}

export function DatabaseError({ error, className }: DatabaseErrorProps) {
  if (!error) return null;

  const isSupabasePaused = error.message?.includes('DATABASE_UNAVAILABLE');

  if (isSupabasePaused) {
    return (
      <div className={`rounded-lg border border-amber-200 bg-amber-50 p-6 ${className || ''}`}>
        <h3 className="text-lg font-semibold text-amber-800">
          База данных приостановлена
        </h3>
        <p className="mt-2 text-amber-700">
          Supabase Free Tier приостанавливает проект после 7 дней неактивности.
        </p>
        <p className="mt-1 text-sm text-amber-600">
          Администратору нужно восстановить проект через{' '}
          <span className="font-medium">Supabase Dashboard → Restore project</span>.
        </p>
      </div>
    );
  }

  return (
    <div className={`rounded-lg border border-red-200 bg-red-50 p-6 ${className || ''}`}>
      <h3 className="text-lg font-semibold text-red-800">
        Ошибка подключения к базе данных
      </h3>
      <p className="mt-2 text-red-700">
        Не удалось загрузить данные. Попробуйте обновить страницу.
      </p>
    </div>
  );
}
```

Use MPSTATS design system colors where applicable (mp-blue, etc.), but amber/red for errors is standard and appropriate.

**2. Update `apps/web/src/app/(main)/dashboard/page.tsx`:**

Update the dashboard page to handle:
- **Error state:** Use `DatabaseError` component when tRPC query fails
- **Empty state (new user):** When `skillProfile` is null and no activity:
  - Show skeleton/empty radar chart placeholder with text "Пройдите диагностику для оценки навыков"
  - Show CTA button linking to /diagnostic
  - Show 0 for all stats
  - Show empty recent activity with "Начните обучение" message
- **Data state:** Show real data from getDashboard

The dashboard page likely already has some empty state handling (from Sprint 2). Review the existing code and enhance it:
- If it checks `dashboard?.skillProfile`, this pattern should work with real null from DB
- Add error boundary: check `trpc.profile.getDashboard.useQuery()` error state
- If error, render `<DatabaseError error={error} />` instead of dashboard content

**Keep existing visual design.** Only add:
- DatabaseError component rendering on tRPC error
- Empty state improvements for new users
- Remove any references to mock data in JSX comments
  </action>
  <verify>
- `pnpm build` passes
- `apps/web/src/components/shared/DatabaseError.tsx` exists and exports `DatabaseError`
- Dashboard page imports and uses `DatabaseError` component
- No references to mock data remain in dashboard page
  </verify>
  <done>
- DatabaseError component shows Supabase 521 message vs generic DB error
- Dashboard handles empty state for new users (null skillProfile, zero stats)
- Dashboard displays real data when available
- Error states don't crash the page
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify full data flow end-to-end</name>
  <files>apps/web/src/app/(main)/dashboard/page.tsx</files>
  <action>
Manual verification of the complete data migration. What was built:
Complete migration of all three routers (learning, diagnostic, profile) from mock data to Prisma/Supabase. Seed scripts ready for populating real course/lesson data.
  </action>
  <verify>
1. Run `pnpm dev` and open http://localhost:3000
2. Log in (Google OAuth or test account)
3. Navigate to /learn — should show courses and lessons (from DB if seeded, or empty if not yet seeded)
4. Navigate to /dashboard — should show empty state for new user (skeleton radar, zero stats, CTA to diagnostic)
5. Start a diagnostic at /diagnostic — complete all 15 questions
6. After completion, check /dashboard — skill profile radar should show real scores
7. Restart the dev server (`Ctrl+C` then `pnpm dev`)
8. Check /dashboard again — skill profile and diagnostic history should persist
9. Check /profile/history — should show completed diagnostic session

If Supabase is unavailable (Error 521):
- Pages should show DatabaseError component with "Base paused" message
- No white screen or crash
  </verify>
  <done>
All data persists across server restarts. Dashboard shows real stats. Empty state works for new users. Supabase 521 shows appropriate message.
Type "approved" or describe issues.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes across entire monorepo
2. `pnpm build` passes (production build)
3. All three routers use `ctx.prisma` for data (no mock imports except questions.ts in diagnostic)
4. `grep -r "MOCK_USER_STATS\|MOCK_RECENT_ACTIVITY\|MOCK_SKILL_PROFILE\|getMockDashboardData\|getMockCoursesWithProgress" packages/api/src/routers/` returns nothing
5. `grep -r "MOCK_QUESTIONS" packages/api/src/routers/diagnostic.ts` returns matches (intentionally kept)
6. DatabaseError component exists and is used in dashboard
7. Data persists across server restarts (E2E manual verification)
</verification>

<success_criteria>
- Dashboard shows real statistics from Supabase
- New users see appropriate empty state
- Diagnostic results persist across server restarts
- Supabase 521 shows specific admin message
- All mock data imports removed except questions.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-04-SUMMARY.md`
</output>
