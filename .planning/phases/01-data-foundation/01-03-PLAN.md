---
phase: 01-data-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/api/src/routers/diagnostic.ts
autonomous: true

must_haves:
  truths:
    - "DiagnosticSession is saved to Supabase with status IN_PROGRESS on start"
    - "Each answer is saved as DiagnosticAnswer row with skillCategory and isCorrect"
    - "SkillProfile is upserted on diagnostic completion and persists across server restarts"
    - "Diagnostic history shows all completed sessions from DB (not in-memory array)"
    - "Mock questions (questions.ts) are still used for question content — only storage moves to DB"
  artifacts:
    - path: "packages/api/src/routers/diagnostic.ts"
      provides: "Prisma-based diagnostic router with session persistence"
      contains: "ctx.prisma.diagnosticSession"
  key_links:
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "packages/db/prisma/schema.prisma"
      via: "DiagnosticSession, DiagnosticAnswer, SkillProfile queries"
      pattern: "ctx\\.prisma\\.(diagnosticSession|diagnosticAnswer|skillProfile)"
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "packages/api/src/mocks/questions.ts"
      via: "Mock questions still used for content (until Phase 2 AI generation)"
      pattern: "MOCK_QUESTIONS|getBalancedQuestions"
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "packages/api/src/utils/ensure-user-profile.ts"
      via: "UserProfile auto-creation before session creation"
      pattern: "ensureUserProfile"
---

<objective>
Migrate the diagnostic router from in-memory globalThis storage to Prisma persistence in Supabase.

Purpose: Diagnostic sessions, answers, and skill profiles must survive server restarts. This is the critical data that drives personalization. Mock questions (questions.ts) are intentionally kept — only the STORAGE moves to DB, question content stays mock until Phase 2 (AI Question Generation).

Output:
- Rewritten diagnostic.ts using Prisma for DiagnosticSession, DiagnosticAnswer, SkillProfile
- Exported helper functions updated to query DB instead of in-memory Maps
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md

@packages/db/prisma/schema.prisma
@packages/api/src/trpc.ts
@packages/api/src/routers/diagnostic.ts
@packages/api/src/mocks/questions.ts
@packages/api/src/utils/ensure-user-profile.ts
@packages/api/src/utils/db-errors.ts
@packages/shared/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite diagnostic router with Prisma persistence</name>
  <files>
    packages/api/src/routers/diagnostic.ts
  </files>
  <action>
Completely rewrite `packages/api/src/routers/diagnostic.ts` to use Prisma for storage while keeping mock questions for content.

**KEEP these imports:**
- `MOCK_QUESTIONS`, `getBalancedQuestions` from `../mocks/questions` (questions stay mock until Phase 2)
- All types from `@mpstats/shared`

**REMOVE:**
- `MOCK_SKILL_PROFILE` from `../mocks/dashboard`
- `MOCK_LESSONS` from `../mocks/courses`
- ALL `globalThis` storage: `mockSessions`, `completedSessions`, `latestSkillProfiles`, `globalForMock`
- `MockSession`, `CompletedSession`, `MockStorage` types

**ADD imports:**
- `ensureUserProfile` from `../utils/ensure-user-profile`
- `handleDatabaseError` from `../utils/db-errors`
- `TRPCError` from `@trpc/server`

**KEEP these functions but update them:**
- `calculateSkillGaps` — keep logic but update `getLessonsByCategory` to query DB instead of `MOCK_LESSONS`:
  ```typescript
  async function getLessonsByCategory(prisma: PrismaClient, category: SkillCategory): Promise<string[]> {
    const lessons = await prisma.lesson.findMany({
      where: { skillCategory: category },
      orderBy: { order: 'asc' },
      select: { id: true },
    });
    return lessons.map(l => l.id);
  }
  ```
  This means `calculateSkillGaps` becomes async — update all callers.

- `getRecommendedLessonsFromGaps` — keep as-is (works on SkillGap[] input)

**REWRITE exported functions:**
- `getLatestSkillProfile(userId)` — now queries DB:
  ```typescript
  export async function getLatestSkillProfile(prisma: PrismaClient, userId: string): Promise<SkillProfile | null> {
    const profile = await prisma.skillProfile.findUnique({ where: { userId } });
    if (!profile) return null;
    return {
      analytics: profile.analytics,
      marketing: profile.marketing,
      content: profile.content,
      operations: profile.operations,
      finance: profile.finance,
    };
  }
  ```
- `getCompletedSessions(userId)` — now queries DB:
  ```typescript
  export async function getCompletedSessions(prisma: PrismaClient, userId: string) {
    return prisma.diagnosticSession.findMany({
      where: { userId, status: 'COMPLETED' },
      orderBy: { completedAt: 'desc' },
    });
  }
  ```

**Rewrite each procedure:**

**`getCurrentSession`:**
- Query DB only: `ctx.prisma.diagnosticSession.findFirst({ where: { userId: ctx.user.id, status: 'IN_PROGRESS' } })`
- Remove the in-memory mockSessions lookup

**`startSession`:**
- Call `ensureUserProfile(ctx.prisma, ctx.user)` first
- Generate question set: `const questions = getBalancedQuestions(15)` (still mock)
- Create DB session: `ctx.prisma.diagnosticSession.create({ data: { userId: ctx.user.id, status: 'IN_PROGRESS', currentQuestion: 0 } })`
- Store question IDs in session — but DiagnosticSession doesn't have a questions field. Two approaches:
  - **Option A (recommended):** Store the question selection as JSON in a temporary storage mechanism. Since questions are mock and fixed, we can regenerate the same set by storing the random seed, OR
  - **Option B (simpler):** Store question IDs in a `questions` JSON field on DiagnosticSession. BUT this requires schema change.
  - **Best approach for MVP:** Store the selected question IDs in the session's metadata. Since the schema doesn't have a metadata field either, the simplest approach is: keep a server-side Map<sessionId, questions[]> for the ACTIVE session only (in-flight state). When answers are submitted, the question content is looked up from MOCK_QUESTIONS by questionId. This is acceptable because:
    - Active sessions are short-lived (minutes)
    - Only storage of COMPLETED data needs to persist
    - This approach requires zero schema changes
  - Use `globalThis` for active session question mapping ONLY (not for completed data):
    ```typescript
    const activeSessionQuestions = (globalThis as any).__activeSessionQuestions ||= new Map<string, typeof MOCK_QUESTIONS>();
    ```
- Return session ID and status

**`getSessionState`:**
- For in-progress sessions: get session from DB, get questions from activeSessionQuestions Map
- For completed sessions: get from DB with answers included
- If session not found in either, return isComplete: true

**`submitAnswer`:**
- Look up question from activeSessionQuestions Map (in-flight state)
- Create DiagnosticAnswer in DB: `ctx.prisma.diagnosticAnswer.create({ data: { sessionId, questionId, answer, isCorrect, difficulty, skillCategory } })`
- Update session currentQuestion: `ctx.prisma.diagnosticSession.update({ ... increment currentQuestion })`
- Check completion (count answers vs 15)
- On completion: calculate skill profile, upsert SkillProfile in DB, update session status to COMPLETED, clean up activeSessionQuestions

**`getResults`:**
- Query DiagnosticSession with answers from DB
- If session is COMPLETED, calculate skillProfile from answers (or read from SkillProfile table)
- Calculate gaps using async `calculateSkillGaps`
- NO fallback to `MOCK_SKILL_PROFILE` — if session not found, return null

**`getHistory`:**
- `ctx.prisma.diagnosticSession.findMany({ where: { userId: ctx.user.id, status: 'COMPLETED' }, orderBy: { completedAt: 'desc' } })`

**Skill Profile Upsert on Completion:**
When a session completes (all 15 answers submitted):
```typescript
await ctx.prisma.skillProfile.upsert({
  where: { userId: ctx.user.id },
  update: { analytics, marketing, content, operations, finance },
  create: { userId: ctx.user.id, analytics, marketing, content, operations, finance },
});

await ctx.prisma.diagnosticSession.update({
  where: { id: sessionId },
  data: { status: 'COMPLETED', completedAt: new Date() },
});
```

**Error handling:** Wrap each procedure in try/catch with `handleDatabaseError(error)`.

**Important edge cases:**
- Server restart during active session: questions Map is lost. Handle gracefully — if sessionId exists in DB but not in activeSessionQuestions, mark session as ABANDONED and prompt user to start new one.
- Multiple active sessions: Only allow one IN_PROGRESS session per user. On startSession, abandon any existing IN_PROGRESS sessions first.
  </action>
  <verify>
- `pnpm typecheck` passes
- No imports from `../mocks/dashboard` remain in diagnostic.ts
- No `globalForMock.mockStorage` references remain
- `MOCK_QUESTIONS` and `getBalancedQuestions` are still imported (questions stay mock)
- `grep "getLatestSkillProfile\|getCompletedSessions" packages/api/src/routers/diagnostic.ts` shows async functions with Prisma queries
  </verify>
  <done>
- DiagnosticSession, DiagnosticAnswer, SkillProfile saved to Supabase via Prisma
- Mock questions (questions.ts) still used for question content
- In-flight session questions stored in minimal server-side Map (only active sessions)
- Completed session data fully persisted in DB
- getLatestSkillProfile and getCompletedSessions query DB (exported for profile router)
- Server restart during active session handled gracefully (ABANDONED status)
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `grep -r "globalForMock\|mockSessions\|completedSessions.*=.*\[\]" packages/api/src/routers/diagnostic.ts` returns nothing (no in-memory persistence)
3. `grep "MOCK_QUESTIONS" packages/api/src/routers/diagnostic.ts` returns matches (mock questions intentionally kept)
4. `grep "ctx.prisma.diagnosticSession" packages/api/src/routers/diagnostic.ts` returns matches (DB persistence)
5. `grep "ctx.prisma.skillProfile" packages/api/src/routers/diagnostic.ts` returns matches (SkillProfile upsert)
</verification>

<success_criteria>
- User completes diagnostic, restarts server — results and SkillProfile are preserved
- Diagnostic history shows all past sessions from DB
- Only one active (IN_PROGRESS) session per user
- Mock questions still used for content (Phase 2 will add AI generation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-03-SUMMARY.md`
</output>
