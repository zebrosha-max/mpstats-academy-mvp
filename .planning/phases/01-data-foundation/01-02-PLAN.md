---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/api/src/routers/learning.ts
  - apps/web/src/app/(main)/learn/page.tsx
  - apps/web/src/app/(main)/learn/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "/learn page displays 6 real courses with 405 lessons from Supabase"
    - "Lesson detail page loads lesson data from Prisma (not mock)"
    - "Lesson progress (watched percent, completion) persists in DB across server restarts"
    - "LearningPath is auto-created on first lesson interaction"
    - "DB errors show error state, not mock fallback"
  artifacts:
    - path: "packages/api/src/routers/learning.ts"
      provides: "Prisma-based learning router"
      contains: "ctx.prisma.course.findMany"
    - path: "apps/web/src/app/(main)/learn/page.tsx"
      provides: "Learn page consuming Prisma data"
      contains: "trpc.learning.getCourses"
  key_links:
    - from: "packages/api/src/routers/learning.ts"
      to: "packages/db/prisma/schema.prisma"
      via: "Prisma Course/Lesson/LessonProgress queries"
      pattern: "ctx\\.prisma\\.(course|lesson|lessonProgress)"
    - from: "packages/api/src/routers/learning.ts"
      to: "packages/api/src/utils/ensure-user-profile.ts"
      via: "ensureUserProfile on write operations"
      pattern: "ensureUserProfile"
    - from: "apps/web/src/app/(main)/learn/page.tsx"
      to: "packages/api/src/routers/learning.ts"
      via: "tRPC client calls"
      pattern: "trpc\\.learning"
---

<objective>
Migrate the learning router from hardcoded mock data to Prisma queries against Supabase.

Purpose: The /learn page must show 6 real courses with 405 lessons from the database. Lesson progress must persist between server restarts. This is the first router migration (simplest — read-heavy, few write operations).

Output:
- Rewritten learning.ts router using Prisma queries
- Updated frontend pages to handle new data shapes (if needed)
- LearningPath auto-creation for progress tracking
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md

@packages/db/prisma/schema.prisma
@packages/api/src/trpc.ts
@packages/api/src/routers/learning.ts
@packages/api/src/utils/ensure-user-profile.ts
@packages/api/src/utils/db-errors.ts
@packages/shared/src/types/index.ts
@apps/web/src/app/(main)/learn/page.tsx
@apps/web/src/app/(main)/learn/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite learning router with Prisma queries</name>
  <files>
    packages/api/src/routers/learning.ts
  </files>
  <action>
Completely rewrite `packages/api/src/routers/learning.ts` to use Prisma instead of mock imports.

**Remove these imports:**
- `MOCK_COURSES`, `MOCK_LESSONS`, `getMockCoursesWithProgress`, `getMockLessonWithProgress`, `getNextLesson` from `../mocks/courses`
- Delete the `mockProgress` Map

**Add these imports:**
- `ensureUserProfile` from `../utils/ensure-user-profile`
- `handleDatabaseError` from `../utils/db-errors`
- `TRPCError` from `@trpc/server`

**Rewrite each procedure:**

**`getCourses`:** Query all courses with lessons and progress for current user.
```typescript
getCourses: protectedProcedure.query(async ({ ctx }) => {
  const courses = await ctx.prisma.course.findMany({
    include: {
      lessons: {
        orderBy: { order: 'asc' },
        include: {
          progress: {
            where: { path: { userId: ctx.user.id } },
          },
        },
      },
    },
    orderBy: { order: 'asc' },
  });

  return courses.map(course => ({
    id: course.id,
    title: course.title,
    description: course.description,
    slug: course.slug,
    imageUrl: course.imageUrl,
    duration: course.duration,
    order: course.order,
    totalLessons: course.lessons.length,
    completedLessons: course.lessons.filter(l =>
      l.progress.some(p => p.status === 'COMPLETED')
    ).length,
    progressPercent: course.lessons.length > 0
      ? Math.round(
          (course.lessons.filter(l => l.progress.some(p => p.status === 'COMPLETED')).length
            / course.lessons.length) * 100
        )
      : 0,
    lessons: course.lessons.map(l => ({
      id: l.id,
      courseId: l.courseId,
      title: l.title,
      description: l.description,
      videoUrl: l.videoUrl || '',
      videoId: l.videoId,
      duration: l.duration || 0,
      order: l.order,
      skillCategory: l.skillCategory,
      skillLevel: l.skillLevel,
      status: l.progress[0]?.status || 'NOT_STARTED',
      watchedPercent: l.progress[0]?.watchedPercent || 0,
    })),
  }));
}),
```

**`getCourse`:** Same as getCourses but filtered by courseId. Use `findUnique` with `include`.

**`getPath`:** Query LearningPath for user. If doesn't exist, return all lessons with progress (no path = browse all).

**`getLesson`:** Query single lesson with course, next/prev lesson, and progress. Use Prisma `findUnique` with `include` for course and progress. For next/prev, query lessons in same course ordered by `order` field.

**`getNextLesson`:** Find first lesson with status NOT_STARTED or IN_PROGRESS for user. If no path exists, suggest first lesson of first course.

**`updateProgress`:**
- Call `ensureUserProfile(ctx.prisma, ctx.user)` first
- Auto-create LearningPath if not exists: `prisma.learningPath.upsert({ where: { userId: ctx.user.id }, ... })`
- Then upsert LessonProgress: `prisma.lessonProgress.upsert({ where: { pathId_lessonId: { pathId, lessonId } }, ... })`
- Mark as COMPLETED if watchedPercent >= 90

**`completeLesson`:** Same as updateProgress but always sets watchedPercent=100 and status=COMPLETED.

**`getLessonSummary`:** REMOVE this procedure from learning router. It's already handled by `ai.getLessonSummary` in the AI router. If frontend still calls `learning.getLessonSummary`, remove that call too.

**Error handling:** Wrap each procedure body in try/catch. In catch, call `handleDatabaseError(error)` from utils.

**Important:** The return types must match the `CourseWithProgress` and `LessonWithProgress` interfaces from `@mpstats/shared`. Map Prisma results to these shapes inline (no separate DTO layer per user decision).
  </action>
  <verify>
- `pnpm typecheck` passes (or `cd packages/api && npx tsc --noEmit`)
- No imports from `../mocks/courses` remain in learning.ts
- `learning.ts` uses `ctx.prisma` for all data operations
  </verify>
  <done>
- Learning router queries Prisma for courses, lessons, and progress
- LearningPath auto-created on first updateProgress/completeLesson
- ensureUserProfile called before write operations
- DB errors handled via handleDatabaseError (no mock fallback)
- Return shapes match CourseWithProgress/LessonWithProgress interfaces
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend learn pages for new data shape</name>
  <files>
    apps/web/src/app/(main)/learn/page.tsx
    apps/web/src/app/(main)/learn/[id]/page.tsx
  </files>
  <action>
Review and update frontend pages that consume learning router data.

**`apps/web/src/app/(main)/learn/page.tsx`:**
- Check how it calls `trpc.learning.getCourses` — the data shape should be compatible since we're mapping to the same `CourseWithProgress` interface
- With 405 lessons (vs 20 mock), the page might need course-level grouping. If lessons are already grouped by course (likely from getCourses returning courses with nested lessons), this should work without changes
- If the page renders ALL lessons in a flat list, add pagination or collapse lessons within courses (show "Show all N lessons" button per course)
- Ensure loading states work (the tRPC query hook should handle this)
- Add error handling: if the query fails, show an error state with appropriate message. Check if `trpc.learning.getCourses.useQuery()` has an `error` state handled in JSX

**`apps/web/src/app/(main)/learn/[id]/page.tsx`:**
- This page calls `trpc.learning.getLesson` — verify it handles the new return shape
- If it was calling `trpc.learning.getLessonSummary`, remove that call (summary is handled by AI router)
- Verify next/prev lesson navigation still works with new data
- Ensure lesson progress update calls (`trpc.learning.updateProgress`) still work

**Error boundary approach:** Per user decision, use per-route error boundaries. If the pages don't already have error handling for tRPC errors:
- Add try/catch or `.error` handling in useQuery hooks
- For DATABASE_UNAVAILABLE errors, show "Database connection error" message
- Keep it simple — just show an error alert/card, not a full error boundary component yet (that's Plan 04 territory for dashboard)

**Do NOT change:**
- Visual design or Tailwind classes (Sprint 2.5 redesign is done)
- Component structure (keep existing components)
- Navigation logic
  </action>
  <verify>
- `pnpm build` passes without errors (frontend compiles)
- `pnpm dev` starts and /learn page loads (manual check — but at least verify no build errors)
- No references to `learning.getLessonSummary` in frontend code
  </verify>
  <done>
- /learn page handles 405 lessons without performance issues (grouped by course)
- Lesson detail page loads from Prisma data
- tRPC error states handled gracefully
- No dead references to removed procedures
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm build` passes (full production build)
3. Learning router has zero imports from `../mocks/courses`
4. `grep -r "getMockCourses\|MOCK_COURSES\|MOCK_LESSONS" packages/api/src/routers/learning.ts` returns nothing
5. `grep -r "learning.getLessonSummary" apps/web/` returns nothing (removed dead reference)
</verification>

<success_criteria>
- /learn page displays courses and lessons from Supabase
- Lesson progress persists in DB (not in-memory Map)
- LearningPath auto-created on first lesson interaction
- No mock fallback — DB errors show error state
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
