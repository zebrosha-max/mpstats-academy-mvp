---
phase: 14-tech-debt-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/prisma/schema.prisma
  - packages/api/src/routers/diagnostic.ts
  - Dockerfile
autonomous: true
requirements:
  - DEBT-01
  - DEBT-04

must_haves:
  truths:
    - "Перезапуск сервера не теряет activeSessionQuestions — активная сессия диагностики восстанавливается из DB"
    - "Prisma version в Dockerfile определяется динамически, а не захардкожена как 5.22.0"
  artifacts:
    - path: "packages/db/prisma/schema.prisma"
      provides: "DiagnosticSession.questions JSON field for persisting question set"
      contains: "questions"
    - path: "packages/api/src/routers/diagnostic.ts"
      provides: "DB-backed session questions instead of globalThis Map"
    - path: "Dockerfile"
      provides: "Dynamic Prisma version detection via glob pattern"
  key_links:
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "packages/db/prisma/schema.prisma"
      via: "ctx.prisma.diagnosticSession with questions JSON field"
      pattern: "session\\.questions"
---

<objective>
Migrate in-memory activeSessionQuestions to database persistence and fix hardcoded Prisma version in Dockerfile.

Purpose: Eliminate data loss on server restart (DEBT-01) and prevent Dockerfile breakage on Prisma upgrades (DEBT-04).
Output: DiagnosticSession stores questions in DB, Dockerfile uses dynamic Prisma path.
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/prisma/schema.prisma
@packages/api/src/routers/diagnostic.ts
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist session questions in DiagnosticSession model + migrate diagnostic router</name>
  <files>
    packages/db/prisma/schema.prisma
    packages/api/src/routers/diagnostic.ts
  </files>
  <action>
1. Add `questions Json?` field to `DiagnosticSession` model in schema.prisma. This stores the full question set as JSON (array of DiagnosticQuestion objects). Nullable because old sessions don't have it.

2. Run `pnpm db:push` to apply schema change (no migration needed, we use db:push pattern).

3. Run `pnpm db:generate` to regenerate Prisma client.

4. In `diagnostic.ts`, remove the entire `globalThis` activeSessionQuestions Map pattern (lines 23-35). Instead:

   - In `startSession`: after generating questions, store them in the DB session:
     ```typescript
     const session = await ctx.prisma.diagnosticSession.create({
       data: {
         userId: ctx.user.id,
         status: 'IN_PROGRESS',
         currentQuestion: 0,
         questions: questions as any, // Prisma Json type
       },
     });
     ```
     Remove `activeSessionQuestions.set(session.id, { questions })`.

   - In `getCurrentSession`: instead of checking `activeSessionQuestions.get(session.id)`, check `session.questions`:
     ```typescript
     const session = await ctx.prisma.diagnosticSession.findFirst({
       where: { userId: ctx.user.id, status: 'IN_PROGRESS' },
     });
     if (!session) return null;
     if (!session.questions) {
       // Legacy session without persisted questions — mark ABANDONED
       await ctx.prisma.diagnosticSession.update({
         where: { id: session.id },
         data: { status: 'ABANDONED' },
       });
       return null;
     }
     ```

   - In `getSessionState`: replace `activeSessionQuestions.get(input.sessionId)` with reading `session.questions` from the already-fetched session (add `questions` to the findUnique select). Cast `session.questions as DiagnosticQuestion[]`. If `session.questions` is null, mark ABANDONED (same legacy handling).

   - In `submitAnswer`: replace `activeSessionQuestions.get(input.sessionId)` with fetching the session's `questions` field:
     ```typescript
     const session = await ctx.prisma.diagnosticSession.findUnique({
       where: { id: input.sessionId },
       select: { questions: true, currentQuestion: true, userId: true },
     });
     const questions = session.questions as DiagnosticQuestion[];
     ```
     Remove `activeSessionQuestions.delete(input.sessionId)` at completion — questions live in DB, no cleanup needed.

   - Remove the `ActiveSessionData` type and the entire `activeSessionQuestions` Map declaration block.

5. Decision (Claude's Discretion): Session timeout — do NOT add a timeout mechanism. Sessions already get ABANDONED when a user starts a new one. This is sufficient for MVP.

6. Decision (Claude's Discretion): Scope — migrate ONLY activeSessionQuestions. completedSessions and skillProfiles are already in DB (migrated in Phase 1). The rate limiter Map stays in globalThis (it's ephemeral by nature — losing it on restart is fine, users just get a fresh rate limit window).
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && pnpm db:generate && pnpm turbo build --filter=@mpstats/api 2>&1 | tail -5</automated>
    <manual>Verify diagnostic.ts no longer contains "globalThis" for activeSessionQuestions</manual>
  </verify>
  <done>DiagnosticSession.questions field exists in schema, diagnostic router reads/writes questions from DB instead of globalThis Map, build passes without errors</done>
</task>

<task type="auto">
  <name>Task 2: Fix hardcoded Prisma version in Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Replace the two hardcoded Prisma version paths in the runner stage (lines 64-65) with a glob-based copy that works regardless of Prisma version:

Replace:
```dockerfile
COPY --from=builder --chown=nextjs:nodejs /app/node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/.prisma/client/*.so.node ./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/.prisma/client/
COPY --from=builder --chown=nextjs:nodejs /app/node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/.prisma/client/schema.prisma ./node_modules/.pnpm/@prisma+client@5.22.0_prisma@5.22.0/node_modules/.prisma/client/
```

With a shell-based approach that finds the Prisma client directory dynamically:
```dockerfile
# Copy Prisma engine binaries — find the directory dynamically (no hardcoded version)
RUN mkdir -p /app/prisma-engines
COPY --from=builder /app/node_modules/.pnpm/ /tmp/pnpm-modules/
RUN PRISMA_DIR=$(find /tmp/pnpm-modules -path '*/@prisma+client@*/node_modules/.prisma/client' -type d | head -1) && \
    cp "$PRISMA_DIR"/*.so.node /app/prisma-engines/ && \
    cp "$PRISMA_DIR"/schema.prisma /app/prisma-engines/
```

Actually, that's too complex and adds a layer. Better approach — use a multi-stage copy with a helper script. But the simplest solution that works in Docker is to use the builder stage to create a known path:

In the **builder** stage (after the build), add:
```dockerfile
# Collect Prisma engine binaries to a known location
RUN mkdir -p /app/prisma-collected && \
    find /app/node_modules/.pnpm -path '*/.prisma/client/*.so.node' -exec cp {} /app/prisma-collected/ \; && \
    find /app/node_modules/.pnpm -path '*/.prisma/client/schema.prisma' -exec cp {} /app/prisma-collected/ \;
```

In the **runner** stage, replace the two hardcoded COPY lines with:
```dockerfile
# Copy Prisma engine binaries — version-independent
COPY --from=builder --chown=nextjs:nodejs /app/prisma-collected/*.so.node ./node_modules/.prisma/client/
COPY --from=builder --chown=nextjs:nodejs /app/prisma-collected/schema.prisma ./node_modules/.prisma/client/
```

Also update the PRISMA_QUERY_ENGINE_LIBRARY env var to point to the new location:
```dockerfile
ENV PRISMA_QUERY_ENGINE_LIBRARY=/app/node_modules/.prisma/client/libquery_engine-linux-musl-openssl-3.0.x.so.node
```

This way the Dockerfile never needs updating when Prisma version changes.
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && grep -c "5.22.0" Dockerfile</automated>
    <manual>Verify Dockerfile no longer contains hardcoded "5.22.0" version string, uses dynamic prisma-collected copy</manual>
  </verify>
  <done>Dockerfile uses version-independent Prisma engine copy pattern, no hardcoded version strings remain</done>
</task>

</tasks>

<verification>
1. `pnpm db:generate` succeeds — Prisma client generated with new questions field
2. `pnpm turbo build --filter=@mpstats/api` succeeds — no TypeScript errors in diagnostic router
3. `grep -c "globalThis.*activeSessionQuestions" packages/api/src/routers/diagnostic.ts` returns 0
4. `grep -c "5.22.0" Dockerfile` returns 0
5. `grep "questions" packages/db/prisma/schema.prisma` shows Json? field on DiagnosticSession
</verification>

<success_criteria>
- DiagnosticSession model has questions Json? field
- Diagnostic router reads/writes questions from DB, no globalThis Map
- Dockerfile copies Prisma engines without hardcoded version
- Both changes build successfully
</success_criteria>

<output>
After completion, create `.planning/phases/14-tech-debt-cleanup/14-01-SUMMARY.md`
</output>
