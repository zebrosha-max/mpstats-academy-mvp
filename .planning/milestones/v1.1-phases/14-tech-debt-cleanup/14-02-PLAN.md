---
phase: 14-tech-debt-cleanup
plan: 02
type: execute
wave: 2
depends_on:
  - 14-01
files_modified:
  - packages/db/prisma/schema.prisma
  - packages/api/src/routers/diagnostic.ts
  - packages/api/src/routers/admin.ts
  - packages/ai/src/question-generator.ts
  - apps/web/src/app/(main)/diagnostic/page.tsx
  - apps/web/src/app/(admin)/content/page.tsx
autonomous: true
requirements:
  - DEBT-02
  - DEBT-03

must_haves:
  truths:
    - "Повторный запуск диагностики по той же категории использует ранее сгенерированные вопросы из банка в DB"
    - "При генерации AI вопросов пользователь видит progressive loading с этапами, а не просто спиннер"
    - "Админ может принудительно обновить банк вопросов через кнопку в админ-панели"
    - "Если AI-банка не хватает — добираются вопросы из fallback-пула mock-вопросов"
  artifacts:
    - path: "packages/db/prisma/schema.prisma"
      provides: "QuestionBank model for cached AI questions with TTL"
      contains: "model QuestionBank"
    - path: "packages/api/src/routers/diagnostic.ts"
      provides: "startSession reads from QuestionBank, triggers lazy refresh if stale"
    - path: "packages/api/src/routers/admin.ts"
      provides: "refreshQuestionBank admin endpoint"
    - path: "apps/web/src/app/(main)/diagnostic/page.tsx"
      provides: "Progressive loading UI with generation stages"
  key_links:
    - from: "packages/api/src/routers/diagnostic.ts"
      to: "QuestionBank model"
      via: "ctx.prisma.questionBank.findMany"
      pattern: "questionBank"
    - from: "apps/web/src/app/(main)/diagnostic/page.tsx"
      to: "diagnostic.startSession"
      via: "tRPC mutation with loading stages"
      pattern: "startSession"
    - from: "packages/api/src/routers/admin.ts"
      to: "generateDiagnosticQuestions"
      via: "refreshQuestionBank mutation"
      pattern: "refreshQuestionBank"
---

<objective>
Implement AI question bank caching in DB with TTL-based refresh, progressive loading UX for diagnostic start, and admin refresh button.

Purpose: Eliminate redundant LLM calls on every diagnostic start (DEBT-02) and improve user experience during question loading (DEBT-03).
Output: QuestionBank DB table, instant diagnostic start from cached questions, admin refresh capability, progressive loading UI.
</objective>

<execution_context>
@C:/Users/Zebrosha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Zebrosha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-tech-debt-cleanup/14-01-SUMMARY.md
@packages/db/prisma/schema.prisma
@packages/api/src/routers/diagnostic.ts
@packages/api/src/routers/admin.ts
@packages/ai/src/question-generator.ts
@packages/api/src/mocks/questions.ts
@apps/web/src/app/(main)/diagnostic/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QuestionBank model and implement bank-based diagnostic start</name>
  <files>
    packages/db/prisma/schema.prisma
    packages/api/src/routers/diagnostic.ts
    packages/api/src/routers/admin.ts
    packages/ai/src/question-generator.ts
  </files>
  <action>
**Schema (packages/db/prisma/schema.prisma):**

Add QuestionBank model after SummaryCache:
```prisma
model QuestionBank {
  id            String        @id @default(cuid())
  skillCategory SkillCategory
  questions     Json          // Array of DiagnosticQuestion objects (~30 per category)
  generatedAt   DateTime      @default(now())
  expiresAt     DateTime      // TTL: generatedAt + 7 days

  @@unique([skillCategory])
}
```

Run `pnpm db:push` and `pnpm db:generate`.

**Diagnostic Router (packages/api/src/routers/diagnostic.ts):**

Add a helper function `getQuestionsFromBank`:
```typescript
const BANK_TTL_DAYS = 7;
const QUESTIONS_PER_BANK_CATEGORY = 30;

/**
 * Get questions from the cached bank, falling back to mock.
 * If bank is stale or missing, triggers async refresh (non-blocking).
 */
async function getQuestionsFromBank(
  prisma: PrismaClient,
  count: number
): Promise<DiagnosticQuestion[]> {
  const categories: SkillCategory[] = ['ANALYTICS', 'MARKETING', 'CONTENT', 'OPERATIONS', 'FINANCE'];
  const perCategory = Math.ceil(count / categories.length); // 3 per category for 15 total
  const allQuestions: DiagnosticQuestion[] = [];

  for (const category of categories) {
    const bank = await prisma.questionBank.findUnique({
      where: { skillCategory: category },
    });

    let categoryQuestions: DiagnosticQuestion[] = [];

    if (bank && new Date(bank.expiresAt) > new Date()) {
      // Bank is fresh — sample random questions from it
      const bankQuestions = bank.questions as DiagnosticQuestion[];
      categoryQuestions = shuffleArray(bankQuestions).slice(0, perCategory);
    }

    // If not enough questions from bank, supplement with fallback mock pool
    if (categoryQuestions.length < perCategory) {
      const needed = perCategory - categoryQuestions.length;
      const mockFallback = getMockQuestionsForCategory(category, needed);
      categoryQuestions.push(...mockFallback);
    }

    allQuestions.push(...categoryQuestions.slice(0, perCategory));

    // If bank is missing or stale, trigger non-blocking refresh
    if (!bank || new Date(bank.expiresAt) <= new Date()) {
      refreshBankForCategory(prisma, category).catch(err =>
        console.error(`[QuestionBank] Failed to refresh ${category}:`, err)
      );
    }
  }

  return shuffleArray(allQuestions);
}
```

Add `refreshBankForCategory` helper:
```typescript
async function refreshBankForCategory(
  prisma: PrismaClient,
  category: SkillCategory
): Promise<void> {
  const questions = await generateDiagnosticQuestions(
    (cat, count) => getMockQuestionsForCategory(cat, count),
    { categories: [category], questionsPerCategory: QUESTIONS_PER_BANK_CATEGORY }
  );

  await prisma.questionBank.upsert({
    where: { skillCategory: category },
    update: {
      questions: questions as any,
      generatedAt: new Date(),
      expiresAt: new Date(Date.now() + BANK_TTL_DAYS * 24 * 60 * 60 * 1000),
    },
    create: {
      skillCategory: category,
      questions: questions as any,
      generatedAt: new Date(),
      expiresAt: new Date(Date.now() + BANK_TTL_DAYS * 24 * 60 * 60 * 1000),
    },
  });
}
```

Modify `startSession` mutation:
- Replace the `generateDiagnosticQuestions` call with `getQuestionsFromBank(ctx.prisma, QUESTIONS_PER_SESSION)`.
- This makes startSession instant when bank exists (no LLM call).
- Keep the full fallback chain: bank -> mock -> getBalancedQuestions.

**Question Generator (packages/ai/src/question-generator.ts):**

Add optional parameter to `generateDiagnosticQuestions` to support single-category generation:
```typescript
interface GenerateOptions {
  categories?: SkillCategory[];
  questionsPerCategory?: number;
}
```
Update the function signature to accept `options?: GenerateOptions`. When `options.categories` is provided, only generate for those categories. When `options.questionsPerCategory` is provided, use that count instead of the default 3. Export the updated function.

**Admin Router (packages/api/src/routers/admin.ts):**

Add `refreshQuestionBank` mutation with `adminProcedure`:
```typescript
refreshQuestionBank: adminProcedure.mutation(async ({ ctx }) => {
  const categories: SkillCategory[] = ['ANALYTICS', 'MARKETING', 'CONTENT', 'OPERATIONS', 'FINANCE'];
  const results: Record<string, { success: boolean; count: number }> = {};

  for (const category of categories) {
    try {
      await refreshBankForCategory(ctx.prisma, category);
      const bank = await ctx.prisma.questionBank.findUnique({ where: { skillCategory: category } });
      const count = bank ? (bank.questions as any[]).length : 0;
      results[category] = { success: true, count };
    } catch (err) {
      results[category] = { success: false, count: 0 };
    }
  }

  return results;
}),
```

Extract `refreshBankForCategory` to a shared utility file or import it. Simplest: export it from diagnostic.ts or create `packages/api/src/utils/question-bank.ts`.

Decision (Claude's Discretion): TTL = 7 days. This provides weekly freshness without excessive LLM costs.
Decision (Claude's Discretion): Bank size = 30 questions per category (150 total). Large enough for variety across multiple diagnostic sessions.
Decision (Claude's Discretion): Exclusion of previously seen questions — best effort via random sampling from 30-question pool. With 30 questions and only 3 needed per session, probability of full repeat is low (~1/4060).
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && pnpm db:generate && pnpm turbo build --filter=@mpstats/api 2>&1 | tail -5</automated>
    <manual>Verify QuestionBank model exists in schema, diagnostic.ts uses getQuestionsFromBank, admin.ts has refreshQuestionBank</manual>
  </verify>
  <done>QuestionBank model in schema, startSession uses cached bank instead of per-request LLM, admin can force-refresh, fallback to mock works when bank empty</done>
</task>

<task type="auto">
  <name>Task 2: Progressive loading UX for diagnostic start + admin refresh button</name>
  <files>
    apps/web/src/app/(main)/diagnostic/page.tsx
    apps/web/src/app/(admin)/content/page.tsx
  </files>
  <action>
**Diagnostic Page (apps/web/src/app/(main)/diagnostic/page.tsx):**

Replace the simple `isStarting` spinner with a progressive loading state that shows stages. Since with the bank-based approach startSession is now fast (DB read, not LLM call), the progressive loading is mainly for the case when the bank is being built for the first time or on refresh.

Add a `loadingStage` state:
```typescript
const [loadingStage, setLoadingStage] = useState<string | null>(null);
```

Update the handleStart function:
```typescript
const handleStart = () => {
  setIsStarting(true);
  setLoadingStage('Подготовка вопросов...');

  // Progressive hints for slower loads
  const timer1 = setTimeout(() => setLoadingStage('Подбираем вопросы по вашему уровню...'), 2000);
  const timer2 = setTimeout(() => setLoadingStage('AI формирует персональный набор...'), 5000);
  const timer3 = setTimeout(() => setLoadingStage('Почти готово, ещё немного...'), 10000);

  startSession.mutate(undefined, {
    onSettled: () => {
      clearTimeout(timer1);
      clearTimeout(timer2);
      clearTimeout(timer3);
    },
  });
};
```

Update the button loading state to show `loadingStage` text instead of just "Загрузка...":
```tsx
{isStarting ? (
  <div className="flex items-center gap-2">
    <svg className="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
    </svg>
    <span>{loadingStage || 'Загрузка...'}</span>
  </div>
) : (
  'Начать диагностику'
)}
```

Also add a subtle progress indicator below the button when loading:
```tsx
{isStarting && (
  <div className="mt-4 text-body-sm text-mp-gray-400 animate-fade-in">
    {loadingStage}
  </div>
)}
```

Decision (Claude's Discretion): Progressive loading style — text-based stage labels with escalating timeouts (2s, 5s, 10s). Simple and informative. No progress bar since we can't estimate actual percentage.

**Admin Content Page (apps/web/src/app/(admin)/content/page.tsx):**

Add a "Обновить банк вопросов" button section at the top or bottom of the content management page:

```tsx
// Add state
const [isRefreshing, setIsRefreshing] = useState(false);
const [refreshResult, setRefreshResult] = useState<Record<string, { success: boolean; count: number }> | null>(null);

const refreshBank = trpc.admin.refreshQuestionBank.useMutation({
  onSuccess: (data) => {
    setRefreshResult(data);
    setIsRefreshing(false);
  },
  onError: () => {
    setIsRefreshing(false);
  },
});
```

Add a Card with:
- Title: "Банк AI-вопросов"
- Description: "Глобальный банк вопросов для диагностики. Автообновление каждые 7 дней."
- Button: "Обновить вопросы" with refresh icon
- After refresh: show result table (category, count, success/fail)

Import the tRPC admin router hook. The button triggers `refreshBank.mutate()`.
  </action>
  <verify>
    <automated>cd "D:/GpT_docs/MPSTATS ACADEMY ADAPTIVE LEARNING/MAAL" && pnpm turbo build --filter=@mpstats/web 2>&1 | tail -5</automated>
    <manual>Open /diagnostic page, click "Начать диагностику" — loading text should show progressive stages. Check /admin/content for "Обновить банк вопросов" button.</manual>
  </verify>
  <done>Diagnostic start shows progressive loading text with escalating stages, admin content page has "Обновить банк вопросов" button with refresh results display</done>
</task>

</tasks>

<verification>
1. `pnpm turbo build --filter=@mpstats/web` succeeds — full app builds
2. QuestionBank model exists in schema with skillCategory unique constraint
3. `grep "getQuestionsFromBank" packages/api/src/routers/diagnostic.ts` confirms bank usage
4. `grep "refreshQuestionBank" packages/api/src/routers/admin.ts` confirms admin endpoint
5. `grep "loadingStage" apps/web/src/app/(main)/diagnostic/page.tsx` confirms progressive loading
6. Admin content page renders refresh button
</verification>

<success_criteria>
- startSession reads from QuestionBank (DB) instead of calling LLM every time
- Stale/missing bank triggers non-blocking background refresh
- Admin can force-refresh all categories via button in admin panel
- Fallback mock pool supplements when bank is empty or insufficient
- Diagnostic start page shows progressive loading text with escalating messages
- Full app builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-tech-debt-cleanup/14-02-SUMMARY.md`
</output>
